from Crypto.Hash import SHA256
from Crypto import Random
from need_to_sort import D_MESG, D_ITER, D_PBLC, D_PRG
from utils import sha256_hash, u16str, u8str
from lmots_pubkey import LmotsPublicKey
from lmots_pvtkey import LmotsPrivateKey
from merkle import Merkle
from lmots_sig import LmotsSignature
from lmots_params import LmotsParams
from enum import Enum


class LmotsType(Enum):
    """
    Leighton-Micali One Time Signature (LMOTS) Algorithm Type Enumeration
    """
    LMOTS_SHA256_M32_W1 = LmotsParams(name="LMOTS_SHA256_M32_W1", n=32, p=265, w=1, ls=7, type_code=0x00000001)
    LMOTS_SHA256_M32_W2 = LmotsParams(name="LMOTS_SHA256_M32_W2", n=32, p=133, w=2, ls=6, type_code=0x00000002)
    LMOTS_SHA256_M32_W4 = LmotsParams(name="LMOTS_SHA256_M32_W4", n=32, p=67, w=4, ls=4, type_code=0x00000003)
    LMOTS_SHA256_M32_W8 = LmotsParams(name="LMOTS_SHA256_M32_W8", n=32, p=34, w=8, ls=0, type_code=0x00000004)

    @staticmethod
    def get_by_type_code(type_code):
        if type_code == LmotsType.LMOTS_SHA256_M32_W1.type_code:
            return LmotsType.LMOTS_SHA256_M32_W1
        elif type_code == LmotsType.LMOTS_SHA256_M32_W2.type_code:
            return LmotsType.LMOTS_SHA256_M32_W2
        elif type_code == LmotsType.LMOTS_SHA256_M32_W4.type_code:
            return LmotsType.LMOTS_SHA256_M32_W4
        elif type_code == LmotsType.LMOTS_SHA256_M32_W8.type_code:
            return LmotsType.LMOTS_SHA256_M32_W8
        else:
            raise ValueError("unknown LMOTS type code", str(type_code))


class Lmots:
    """
    Leighton-Micali One Time Signature (LMOTS) Algorithm
    """

    def __init__(self, lmots_type=LmotsType.LMOTS_SHA256_N32_W8, entropy_source=None):
        """
        Initializer.
        :param lmots_type: LMOTS algorithm type
        :param entropy_source: entropy source
        """
        self.lmots_type = lmots_type
        if entropy_source is None:
            self._entropy_source = Random.new()
        else:
            self._entropy_source = entropy_source

    def generate_key_pair(self, s=None, seed=None):
        """
        Generates a LMOTS key pair.
        :param s: entropy s value; if None then random bytes read from entropy source
        :param seed: seed value; if None then random bytes read from entropy source
        :return: key pair set (public key, private key)
        """
        pvt_key = self.generate_private_key(s, seed)
        pub_key = self.generate_public_key(s, pvt_key)
        return pub_key, pvt_key

    def generate_private_key(self, s=None, seed=None):
        """
        Generate a LMOTS private key.  In most cases, a key-pair is generated by calling the generate_key_pair
        method.  Since LMOTS public keys can be derived from the private key later, it is valid to simply
        create the private key only and compute the public key at a different time.
        Algorithm 0.
        :param s: entropy s value; if None then random bytes read from entropy source
        :param seed: seed value; if None then random bytes read from entropy source
        :return: LMOTS private key object
        """
        if s is None:
            s = self._entropy_source.read(self.lmots_type.n)
        raw_key = list()
        if seed is None:
            for i in xrange(0, self.lmots_type.p):
                raw_key.append(self._entropy_source.read(self.lmots_type.n))
        else:
            for i in xrange(0, self.lmots_type.p):
                raw_key.append(sha256_hash(s + seed + u16str(i + 1) + D_PRG))

        return LmotsPrivateKey(lmots_type=self.lmots_type, raw_key=raw_key, s=s, seed=seed, signatures_remaining=1)

    def generate_public_key(self, s, pvt_key):
        """
        Generate LMOTS public key from a private key.  In most cases, a key-pair is generated by calling the
        generate_key_pair method.  Alternatively the public key can be derived from the private key at any time.
        Algorithm 1.
        :param s: entropy s value
        :param pvt_key: LMOTS private key object
        :return: LMOTS public key object
        """
        outer_hash = SHA256.new()
        outer_hash.update(s)
        for i, pvt_key in enumerate(pvt_key.raw_key):
            tmp = pvt_key
            for j in xrange(0, 2 ** self.lmots_type.w - 1):
                tmp = sha256_hash(s + tmp + u16str(i) + u8str(j) + D_ITER)
            outer_hash.update(tmp)
        outer_hash.update(D_PBLC)

        return LmotsPublicKey(s=s, k=outer_hash.digest(), lmots_type=self.lmots_type)

    def sign(self, message, pvt_key):
        """
        Generate a cryptographic signature for the supplied message using a LMOTS private key.
        Algorithm 3: Generating a Signature from a Private Key and a Message
        :param message: message bytes
        :param pvt_key: LMOTS private key object
        :return: LMOTS signature object
        """
        if pvt_key.signatures_remaining != 1:
            raise ValueError("private key has no signature operations remaining")

        c = self._entropy_source.read(self.lmots_type.n)
        hash_q = sha256_hash(pvt_key.s + c + message + D_MESG)
        v = hash_q + Merkle.checksum(hash_q, self.lmots_type.w, self.lmots_type.ls)
        raw_sig = list()
        for i, x in enumerate(pvt_key.raw_key):
            tmp = x
            for j in xrange(0, Merkle.coef(v, i, self.lmots_type.w)):
                tmp = sha256_hash(pvt_key.s + tmp + u16str(i) + u8str(j) + D_ITER)
            raw_sig.append(tmp)
            pvt_key.signatures_remaining = 0
        return LmotsSignature(c, raw_sig, pvt_key.type_code).serialize()

    def verify(self, message, signature, s, k):
        """
        Verify a LMOTS signature using the message and s and k values.
        Algorithm 4: Verifying a Signature and Message Using a Public Key
        :param message: original message bytes
        :param signature: signature to verify
        :param s: entropy s value
        :param k: k value
        :return: true if valid; otherwise false
        """
        pub_key = self.extract_public_key(signature, s, message)
        is_valid = k == pub_key.k
        return is_valid

    def extract_public_key(self, signature, s, message):
        """
        Extracts a LMOTS public key object from a LMOTS signature and the s value.
        :param signature: LMOTS signature
        :param s: entropy s value
        :param message: original message
        :return: LMOTS public key object
        """
        signature = LmotsSignature.deserialize(signature)
        if signature.type != self.lmots_type.type_code:
            raise ValueError("signature type code does not match expected value")
        hash_q = sha256_hash(s + signature.C + message + D_MESG)
        v = hash_q + Merkle.checksum(hash_q, self.lmots_type.w, self.lmots_type.ls)
        outer_hash = SHA256.new()
        outer_hash.update(s)
        for i, y in enumerate(signature.y):
            tmp = y
            for j in xrange(Merkle.coef(v, i, self.lmots_type.w), 2 ** self.lmots_type.w - 1):
                tmp = sha256_hash(s + tmp + u16str(i) + u8str(j) + D_ITER)
            outer_hash.update(tmp)
        outer_hash.update(D_PBLC)

        return LmotsPublicKey(s=s, k=outer_hash.digest())
